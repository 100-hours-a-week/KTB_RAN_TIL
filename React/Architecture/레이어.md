

# 레이어 정의 (Layer Definition)

본 문서는 FSD 아키텍처에 따라 `App → Pages → Widgets → Features → Entities → Shared` 중
**App / Pages / Entities 레이어의 책임과 배치 기준**을 명확히 정의한다.

---

## 1. App Layer

`1.1 역할 (Responsibility)`
* 애플리케이션 전반에 영향을 미치는 **최상위 레이어**
* 가장 많은 책임과 의존성을 가진다.
* 특정 도메인이나 화면에 종속되지 않는 **앱 단위 설정**을 담당한다.

- 주요 책임
  * 전역 Context Provider 구성
  * 전역 상태(Store) 초기화
  * 분석/로깅/모니터링 도구 설정
  * 런타임 전반에 영향을 주는 공통 정책 정의



`🔸 1.2 App 레이어의 일반적 세그먼트`

| 세그먼트         | 설명                                             |
| ------------ | ---------------------------------------------- |
| `routes`     | 라우팅 구조 및 라우터 엔트리 정의                            |
| `store`      | 전역 상태 관리(Zustand 등)                            |
| `styles`     | 글로벌 스타일, 리셋, 테마                                |
| `entrypoint` | 프레임워크 특화 진입점 (`layout.tsx`, `providers.tsx` 등) |


`🔸 1.3 배치 기준 및 의존성 규칙`

* App 레이어는 **모든 하위 레이어를 참조할 수 있다**
* App 레이어는 **비즈니스 로직을 직접 구현하지 않는다**
* 특정 페이지·기능에 종속된 로직이 포함될 경우, **하위 레이어로 이동**해야 한다

---

## 2. Pages Layer

`🔸 2.1 역할 (Responsibility)`

* **개별 화면 단위(Page)** 를 정의하는 레이어
* **1 Page = 1 Slice** 원칙을 따른다
* 사용자 진입 지점이며, 여러 Feature·Widget을 조합하는 역할을 한다
- 주요 특징   
  * 라우트 단위의 UI 구성
  * 페이지 수준의 데이터 요청 및 흐름 제어
  * 여러 엔티티/기능 간의 조합 및 오케스트레이션

※ 로그인/회원가입처럼 **강하게 연관된 페이지**는 하나의 슬라이스로 그룹화할 수 있다.



`🔸 2.2 Pages 레이어의 일반적 세그먼트`

| 세그먼트            | 설명                     |
| --------------- | ---------------------- |
| `ui`            | 페이지 UI, 로딩 상태, 에러 바운더리 |
| `api`           | 페이지에서 필요한 데이터 조회/수정 요청 |
| `logic / state` | 페이지 전용 로직 및 소규모 상태     |

- 상태 관리 기준

  * 페이지 전용 상태는 **컴포넌트 내부 상태로 유지**
  * 엔티티 간 복잡한 상호작용은 **Pages 레이어에서 조율**
  * 전역 상태로 승격할 필요가 없는 로직만 유지



`🔸 2.3 다른 레이어와의 관계 및 배치 기준`

#### Widgets와의 구분 기준

* **다른 페이지에서 재사용되지 않는 UI 블록**은
  Widgets로 분리하지 않고 Pages 내부에 유지한다.
* 재사용 목적이 명확한 경우에만 Widgets로 승격한다.

#### 의존성 규칙

* Pages → Widgets / Features / Entities / Shared : **참조 가능**
* Pages → App : **참조 불가**
* Pages는 **하위 레이어만 의존**해야 한다.

---

## 3. Entities Layer

`🔸 3.1 역할 (Responsibility)`

* 비즈니스 도메인에서 사용하는 **핵심 개념(Entity)** 을 코드로 표현하는 레이어
* 데이터 모델, 유효성 규칙, 기본 UI 표현을 함께 관리한다
- 주요 책임
  - Entities에서는 비즈니스 조합 로직을 하지 않는다 
  - API는 엔티티 단위 CRUD 최소 집합 
  - 상태는 “전역 UI 상태”가 아니라 도메인 모델 정의에 가깝다

예시:

* 사용자(User)
* 작업(Task)
* 플래너(Planner)
* 채팅방(ChatRoom)


`🔸 3.2 Entities 레이어의 일반적 세그먼트`

| 세그먼트    | 설명                       |
| ------- | ------------------------ |
| `model` | 상태 모델, 타입 정의, 유효성 검사 스키마 |
| `api`   | 엔티티 단위 API 요청            |
| `ui`    | 엔티티의 기본 시각적 표현           |


`🔸 3.3 예시 구조`

```
entities/
└─ user/
    ├─ model/
    │   ├─ types.ts
    │   ├─ schema.ts
    │   └─ index.ts
    ├─ api/
    │   ├─ user.api.ts
    │   └─ index.ts
    ├─ ui/
    │   ├─ UserAvatar.tsx
    │   └─ index.ts
```

#### **model — 상태 모델 / 타입 / 유효성 스키마**
- 서버 응답과 1:1 매핑되는 도메인 타입
- 주의 : 화면 상태나 UI 전용 필드는 포함하지 않는다

` model/types.ts`
```ts
export interface User {
   id: string;
   email: string;
   nickname: string;
   profileImageUrl?: string;
   createdAt: string;
}
```

`model/schema.ts` (예: zod)
- 서버 응답 검증 목적
- API boundary에서만 사용
- UI 로직에서는 직접 사용하지 않는다

```ts
import { z } from "zod";

export const userSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  nickname: z.string().min(1),
  profileImageUrl: z.string().url().optional(),
  createdAt: z.string(),
});

export type UserSchema = z.infer<typeof userSchema>;

```
#### api — 엔티티 단위 API 요청
- fetch 기반 공통 래퍼 (apiFetch)
- 주의 : Entities 레이어에서는 
  - TanStack Query 훅을 만들지 않는다
  - 순수 요청 함수만 제공


`api/user.api.ts`
```ts
import { apiFetch } from "shared/api";
import type { User } from "../model";

export const getUser = (userId: string) => {
  return apiFetch<User>(`/users/${userId}`, {
    method: "GET",
  });
};

export const updateUser = (
  userId: string,
  payload: Pick<User, "nickname" | "profileImageUrl">,
) => {
  return apiFetch<User>(`/users/${userId}`, {
    method: "PUT",
    body: payload,
  });
};
```

#### ui — 엔티티의 기본 시각적 표현
- 단일 엔티티를 표현하는 최소 UI
- UI 설계 원칙
    - 엔티티 UI는 **완전한 기능 블록이 아님**
    - 외형 재사용을 위한 최소 단위 UI 제공
    - 비즈니스 로직은 `props` 또는 `slots`로 외부 주입

`ui/UserAvatar.tsx`
```tsx
import type { User } from "../model";

interface UserAvatarProps {
  user: User;
  size?: number;
}

export function UserAvatar({ user, size = 32 }: UserAvatarProps) {
  return (
    <img
      src={user.profileImageUrl ?? "/default-avatar.png"}
      alt={user.nickname}
      width={size}
      height={size}
      style={{ borderRadius: "50%" }}
    />
  );
}

```



`🔸 3.3 엔티티 간 관계 및 참조 규칙`

Entities 레이어의 핵심 원칙은 **슬라이스 간 격리(Isolation)** 이다.

#### 기본 원칙

* 각 엔티티 슬라이스는 **서로를 직접 참조하지 않는다**
* 엔티티 간 상호작용 로직은 **상위 레이어에서 처리**

#### 상호작용 로직의 위치

| 로직 유형            | 위치               |
| ---------------- | ---------------- |
| 단일 엔티티 내부 규칙     | Entities         |
| 여러 엔티티 간 비즈니스 로직 | Features / Pages |

#### 교차 참조 (@x 표기법)

* 한 엔티티가 다른 엔티티를 포함해야 하는 경우 사용
* 예: `Artist` → `Song[]`
* 슬라이스 격리 규칙을 **명시적으로 우회**하기 위한 수단
* 리팩토링 시 연관 엔티티를 함께 고려할 수 있도록 돕는다



`🔸 3.4 다른 레이어와의 관계 및 배치 기준`

* Entities → Shared : **참조 가능**
* Entities → Features / Widgets / Pages / App : **참조 불가**
* 동일 Entities 레이어 내 **수평 참조 금지**


##  Features

Features 레이어는 사용자 행동 단위의 기능(Use Case) 을 표현하는 계층이다.
Entities가 “무엇인가(What)”를 정의한다면,  Features는 “무엇을 한다(How it is used)”에 해당한다.

1. 역할
- 하나의 사용자 상호작용 또는 기능 흐름을 캡슐화한다
- 여러 페이지에서 재사용되는 기능 로직을 담당한다
- 엔티티 간 상호작용 및 비즈니스 규칙을 구현한다

Features는 UI 조각이 아니라 **기능 단위**이며,
모든 로직을 Features로 올리는 것을 지양한다.

> 판단 기준

- 재사용성 
  - 동일한 기능이 두 개 이상의 페이지에서 반복 사용되는가 
  - 예: 댓글 작성, 좋아요 토글, 일정 자동 배치 요청
- 의미 단위 
  - 하나의 명확한 사용자 행동으로 설명 가능한가 
  - “데이터를 보여준다”가 아니라 “사용자가 수행한다”에 가까운가 
  

-> 단일 페이지에서만 사용되는 로직은 Pages 레이어에 두는 것이 더 적절하다.

2. 내부 구조 (세그먼트)

| 세그먼트     | 역할                                 |
| -------- | ---------------------------------- |
| `ui`     | 사용자 상호작용을 수행하는 UI (폼, 버튼, 액션 컴포넌트) |
| `api`    | 기능 실행에 필요한 API 호출 함수               |
| `model`  | 기능 단위 상태 관리, 내부 데이터 모델, 유효성 검사     |
| `config` | 기능 플래그, 옵션, 기능별 설정값                |


3. 다른 레이어와의 관계
*   **엔티티와의 협업**: 엔티티(Entities)는 고립된 데이터 모델
    * **엔티티 간의 조합, 규칙, 흐름은 Features에서 담당한다**
    * User + Planner + Task를 함께 다루는 로직 
    * 단일 엔티티로 표현할 수 없는 사용자 행동
*   **의존성 규칙 (Import Rule)**:
    *   **참조 가능**: **Entities** 및 **Shared** 
    *   **참조 불가능**:
         - 동일한 Features 레이어의 다른 기능 슬라이스 (기능 간 수평 의존 금지)
         - 상위 레이어인 Widgets, Pages, App

---

## 배치 기준 요약
- 기능이 여러 페이지에서 재사용된다 → Features
- 엔티티 간 비즈니스 상호작용이다 → Features
- 단일 페이지 전용 로직이다 → Pages
- 순수 데이터 모델이다 → Entities
- 표현 중심 UI이다 → Widgets

---

## 헷갈림 방지

### 각 세그먼트의 ui 역할

UI의 “모양”은 Widget,
UI의 “행동(기능)”은 Feature다

> 역할 : 이것은 A버튼이다.

`widgets/button/ui/PrimaryButton.tsx`
```tsx
interface PrimaryButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
}

export function PrimaryButton(props: PrimaryButtonProps) {
  return <button {...props} />;
}

```

> 역할 : A버튼은 플래너를 저장한다.

`features/save-planner/ui/SavePlannerButton.tsx`
```tsx

// features/save-planner/ui/SavePlannerButton.tsx
import { useSavePlanner } from "../model/useSavePlanner";

export function SavePlannerButton() {
  const { save, isLoading } = useSavePlanner();

  return (
    <PrimaryButton onClick={save} disabled={isLoading}>
      저장하기
    </PrimaryButton>
  );
}

```