

#  Thread (스레드)





하나의 프로그램 안에서 **동시에 실행 가능한 독립적인 실행 단위**

즉, 하나의 프로세스 내에서 여러 흐름을 만들어주는 녀석이다.

---

### 라면 끓이기로 이해하기

* **싱글 스레드 (직원 1명)**

    1. 물 끓인다 → 기다림
    2. 면 넣는다 → 기다림
    3. 스프 넣는다 → 기다림

  -> 모든 작업이 **순차적으로 진행**되기 때문에 전체 시간이 오래 걸림

* **멀티 스레드 (직원 여러 명)**

    * 직원 A : 물 끓인다
    * 직원 B : 면 꺼낸다
    * 직원 C : 그릇 준비한다

  -> 동시에 진행되니까 전체 시간이 단축됨

---

### 스레드가 필요한 이유

* 순차적(단일 스레드) 처리 시 전체 응답이 느려지고 비효율적
* 여러 작업을 동시에 수행하여 **응답성을 향상**시키고,
* **데이터 병렬 처리**(예: 여러 사용자 요청, 다중 입출력)를 가능하게 한다.

---

## Thread 생성 방법

1. `Thread` 클래스 상속
2. `Runnable` 인터페이스 구현
3. `start()` 메서드 호출로 실행

스레드를 실행하면 **main과는 별개의 흐름**으로 병렬 처리된다.
(참고: `main()`의 실행 흐름도 결국 “하나의 스레드”다!)

---

### 예제

```java
class DrivingCar extends Thread {
    @Override
    public void run() {
        System.out.println("자동차 주행 스레드 실행 중: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        DrivingCar car = new DrivingCar();
        car.start(); // main이 아닌, 새로운 스레드에서 병렬 처리
    }
}
```

---

### run() vs start()

| 구분        | 설명                                            |
| --------- | --------------------------------------------- |
| `run()`   | 단순히 메서드 호출. → **main 스레드 내에서 실행**             |
| `start()` | 새로운 스레드를 생성 → 내부적으로 run()을 실행함 (**병렬 처리 시작**) |

```java
car.run();   // main 스레드 내 실행
car.start(); // 새로운 스레드에서 run() 실행
```



##  Thread의 생명주기

OS의 프로세스 상태 전이와 유사하다.

**큰 흐름:**
`new` → `Runnable(실행 대기)` → `Running(실행 중)` → `Waiting` → `Terminated`



---

## 프로세스와 스레드의 차이

| 구분    | 프로세스                      | 스레드                       |
| ----- | ------------------------- | ------------------------- |
| 실행 단위 | 독립적인 실행 단위                | 프로세스 내 실행 단위              |
| 메모리   | 각자 독립된 메모리 공간             | 동일한 프로세스 메모리 공간 공유        |
| 영향    | 한 프로세스 오류 → 다른 프로세스 영향 없음 | 한 스레드 오류 → 프로세스 전체에 영향 가능 |
| 예시    | 크롬 창 1개당 프로세스             | 크롬 창 안의 여러 탭 = 스레드        |

 그래서 크롬은 **“창 단위 프로세스” 구조**로 설계되어 있음 (탭 죽어도 전체 안죽게)

---

## ️ 스레드 동시성 문제

스레드는 한 프로세스의 메모리를 **공유**한다.
그래서 “하나의 변수”를 여러 스레드가 동시에 수정하면
**예상치 못한 결과(Dirty Read, Race Condition)** 가 발생할 수 있다.




### 왜 스레드 간 변수 값이 다르게 보일까?

1. 스레드는 CPU 코어 위에서 동작한다.
2. CPU는 메인 메모리 접근이 느리므로, **변수 값을 캐시나 레지스터에 복사**해 사용한다.
3. 즉, 메인 메모리의 값이 바뀌어도
   각 스레드는 자신이 가진 **작업 메모리(Cache)** 값을 계속 참조할 수 있다.

```text
[하드웨어 관점]  CPU 캐시/레지스터 <-> 메인 메모리
[JMM 관점]      작업 메모리 <-> 주 메모리
```

→ 그래서 하나의 스레드에서 값을 바꿔도,
다른 스레드는 그 변경을 바로 보지 못할 수 있다.

---

## 해결 방안

### volatile 키워드

모든 스레드가 변수를 **항상 메인 메모리에서 읽고 쓰게 강제**한다.
→ 캐시를 우회하기 때문에 값의 일관성이 보장된다.

```java
private static volatile boolean stop = false;
```

> 단, `volatile`은 **원자성(atomicity)** 을 보장하지 않는다.
> 즉, `count++` 같은 복합 연산에는 여전히 안전하지 않다.

---

### synchronized / Lock 사용 (임계구역)

동시에 접근하면 안 되는 코드 영역을 잠그는 방식.
한 스레드만 해당 블록을 실행할 수 있다.

```java
synchronized (this) {
    count++;
}
```

> Lock을 걸면 공유 자원에 대한 동시 접근을 방지할 수 있다.
> 단, 너무 많이 사용하면 **병목 현상 (성능 저하)** 발생.

---
