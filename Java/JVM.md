## JVM

JAVA 바이트 코드를 실행하는 가상 머신임.


→ 운영체제에 관계 없이 동일하게 작동할 수 있도록 함.

→ 바이트 코드 : JVM 전용 바이트 코드임.

- **javac :** 컴파일 프로그램 : java compiler

JAVA 코드를 **javac**가 바이트 코드(.class)로 바꿔줌.

자바코드에서 javac → jvm(javac)

![image.png](attachment:8b6a646e-1431-48a9-87aa-ace54a3052ca:image.png)

Java는 컴파일과 인터프리터의 장점을 결합함.

- 어셈블리어 : 컴퓨터가 읽을 수 있는 수준의 언어

- 컴파일 : 고급언어를 저수준 언어로 바꿈

-> 컴파일은 한번에 기계어로 변환되는 것이 아니라, **여러번의 컴파일 과정**을 거쳐서 기계어로 도달하는 것임.

- JVM은 자바 프로그램을 실행하기 위한 가상 머신임. 정확하게 말하자면 바이트 코드를 실행하기 위한 가상 머신임.

-> JVM이 담당하는건 바이트코드 부터.
JVM만 있으면 어느 운영체제에서든 java를 실행할수있음.

- JVM은 바이트코드를 기계어로 변환하는 과정을 담당함.

- JVM의 속도한계를 커버하기 위해 JIT 컴파일을 사용한다.

- 실시간 중에 기계어로 바꾼다는 뜻.

1. 프로그램을 한 줄씩 번역해서 실행
2. 그런데 어떤 코드가 계속 반복적으로 실행됨. → 핫스팟 발견
3. **JVM이 해당 부분을 CPU 기계어로 바꾸어서 저장해둠.(캐싱)**
4. 이후엔 그 기계어 부분을 가져와서 사용.
- **왜?** 컴파일이라고 부르나? 한 줄씩 번역하면 인터프리터 아닌가? 
 
 -> 인터프리터와 컴파일 이렇게 두 종류가 아닌가? 꼭 두종류로 부르진 않는다.


- 💡**메모리 로드란?**
    - 메모리에 자바 프로그램이 **실행하기 위해** 필요한 클래스와 객체를 JVM 메모리에 옮기고, 자바 프로그램이 **실행될때** 필요한 데이터와 코드를 메모리에서 사용.

JVM 메모리는 무엇인가? 용량은 어떻게 되는가?
  - 
- **둘다 실행 도중 그때그때 로딩한다면, 지연로딩과 JIT의 차이**
    - 지연로딩 필요할때만 리소스를 로딩한다는게 뭐임??
- **지연로딩의 사용 이유?**

>**클래스 로딩 단계**

JVM의 .class 코드를 실행 시점에 필요한 바이트코드를 **클래스 로더**가 **JVM 메모리 안의 runtime data area 중 하나인 메서드 영역안에 저장을 함. → 이후 해당 정보를 활용해 객체를 만들고 사용함.**

- **지연 로딩을 왜 쓰나요?**
    - **메모리 절약**
        - 한번에 모든 클래스나 코드를 메모리에 올리면 **사용하지 않는 클래스까지** **메모리에 차지하게 됨** : 즉시 로딩(eager loading) → 지연로딩은 정말 필요한 시점에서만 필요한 클래스를 메모리에 올리기 때문에 **전체적인 메모리 사용량을 줄일 수 잇음.**
    - **초기 로딩 시점의 속도 개선**
        - 한번에 메모리에 로드할 때, **초기 구동 시간이 길어질수있음.** → 필요할때만 메모리에 로드하기 때문에 **프로그램 시작 시 초기 속도가 빨라짐**

→ **클래스 로딩단계**에서 **바이트 코드**를 **클래스 로더**가 **JVM 메모리 안의** *현재 실행되고있는 시점의 데이터 영역*이라는 뜻을 가지고 있는 **runtime data area 중 메서드 영역**에, 필요한 시점에 필요한 클래스를 로딩하는 **지연 로딩**을 사용함.

**📖 헷갈림.**

클래스 로딩단계는 메서드 영역 메모리에 클래스 정보를 올려두는 단계. 컴파일 단계가 아님! -

road = 메모리를 적재하다. 라는 뜻

→ 클래스 로딩 단계에서 클래스가 메모리에 잘 저장했는지 확인하기 위한 단계가 **링킹 단계**

> **링킹 단계**

클래스가 메모리에 잘 저장되어 있는지 확인함.

로딩단계에서 메모리에 올라온 클래스 정보는 심볼릭 레퍼런스로 되어있음. 해당 메모리에 올라와있는 클래스 내부의 상수 풀 등의 **심볼릭 레퍼런스**를 **다이렉트 레퍼런스**로 변환한다.

- **심볼릭 레퍼런스 :**   참조 대상의 논리적 네임
- **다이렉트 레퍼런스 :** 실제 메모리 주소를 참조하는 값
    - **왜 실제 메모리 주소값이 아닐까?**
        - JVM은 가상 환경이기 때문에, 물리적인 실제 메모리 주소를 그래도 사용하는 것이 아니라, **JVM 내부적으로 관리되는 참조 값**을 사용합니다.

💡 **스레드** : 프로세스 안에서 실행되는 **가장 작은 작업 단위**

---

## Runtime Data Area 구성

메모리영역이 면접에 자주나옴

> **메서드 영역**
>

(지연 로딩)필요한 시점에 **필요한 클래스를 저장**할 때, 해당 **클래스나 코드 데이터가 저장되는 영역**

- 모든 클래스의 정보가 저장되기 때문에, 모든 스레드에서 공유하는 구조
- 지연 로딩으로 메서드 영역에 메모리가 적재될 때, 런타임 상수 풀로 바뀌어서 적재되는건가?
- **런타임 상수 풀**
    - **상수 풀이란?**
        - 필요한 값이나 참조정보들을 모아둔 테이블
        - **상수 풀의 장점**
            - 상수 풀이 있기 때문에, 같은 문자가 여러번 사용되어도 메모리에는 한번만 적재되어있음.
        - **런타임 상수 풀이란?**
            - 공용 데이터 저장소 역할을 함.

- **필드 / 메서드 데이터**
    - 클래스에 정의된 변수와 시그니처 정보가 저장되어 있음
    - **클래스의 구조를 이해하기 위한 정보**

      → 호출시마다 스택 영역에서 프레임을 만들어서 실행함.


- **메서드 코드**
    - 클래스에 정의된 각 메서드의 **바이트 코드를 저장**하는 공간



- **생성자 코드**
    - **객체 초기화에 필요한 로직**으로, 생성자 코드가 바이트 코드로 저장 되어있음.

- **리터럴 뜻**
    - 소스 코드에서 직접 작성하여 변수에 넣은 값

    ```tsx
    int a = 10 //정수 리터럴
    double pi = 3.141592 //실수 리터럴 
    ```


> **힙 영역**
>

JVM이 실행되면서 **동적으로 생성되는 객체를 저장하는 메모리 공간.**

객체들이 자동으로 메모리를 할당 받고, 제거되는 **가비지 컬렉션의 대상**이 됩니다.

**힙에는 어떤 데이터가 저장되나요?**

객체 인스턴스 생성 및 레퍼런스 타입의 실제 데이터가 저장됨.

힙에 있는 객체는 스택을 통해 접근 가능하다.

![IMG_ADB7D830901C-1.jpeg](attachment:cb0d183a-9bff-4b28-b90f-d64e34dbf90e:IMG_ADB7D830901C-1.jpeg)

**힙 : 집 | 스택 : 주소록**

- 해당 부분이 C의 포인터와 깊은 관계가 있음.

**참조 타입이란,**

- 자바에는 기본 타입과 참조 타입으로 존재하는데, 기본타입이 아닌 타입은 모두 참조 타입이다.
- 참조타입의 특징은 스택에 저장되어있는 값은 힙에 저장되어있는 값이 있는 주소이다.

---

## 스택 영역

힙과 반대로, 기본형 변수가 저장되는 곳

각 스레드마다 고유한 스택이 생성됨.

>**JIT 컴파일 단계**

- 클래스 로딩단계에서 메모리에 옮긴 데이터를 사용하여 코드를 쓰는 단계

**💡 캐싱**

자주 쓰는 것을 빠른 장소에 저장해두고 다음에 바로 쓰기

**💡 JIT**

자바의 바이트코드(.class)를 프로그램 실행 도중에 실시간으로 기계어로 변환하여 캐싱하여 읽음

![image.png](attachment:8f9cd298-330e-4baf-adff-01833cb99718:image.png)

클래스 로딩

- hotspot JVM : JVM을 실제로 구현해놓은 구현체

  → Oracle/openJDK의 표준 JVM 구현체

- **Java Class Library**

자바가 실행에 필요한 표준 메소드 모음

**JVM은 JCL과 함께** 운영체제 위에서 실행될 수 있는 기반 환경이 필요함.

이때 이 환경을 JRE

## JRE

- JRE의 정의 : 자바 어플리케이션이 실행될 수 있도록 **JVM과 JCL을 제공하는 소프트웨어 계층**

- 이때, 개발도구가 포함되어있으면 jdk / 개발도구가 포함되어있지않으면 jre 때문에 JRE는 (개발도구없으므로) 실행만 하는 환경에 적합한 최소 실행 환경.

- 이때 개발도구 있을 경우 JDK 까지 사용한다.

**개발이 완료된 자바 프로그램**을 **서비스하는 서버에는 JDK** 대신 JRE만 설치하는 게 운영 효율적이므로 더 일반적이다.

![image.png](attachment:3e2c5066-6beb-4f79-9f72-c8bb0f93d1aa:image.png)

> 개발자 입장

JDK : 개발단계에서만 사용됨.

최종 배포시에는 JRE까지만 포함된 환경에서 검증과정을 확인함.

**→ JRE는 경량화된 구성으로 운영 환경을 단순화할 때 중요한 역할을 함.**

```tsx
 ┌───────────────────────────────┐
 │           JDK                │  ← 개발환경 (JRE + 개발도구)
 │  (javac, javadoc, 디버거 등) │
 └─────────────▲─────────────────┘
               │
 ┌─────────────┴─────────────────┐
 │             JRE               │  ← 실행환경 (JVM + 표준 라이브러리)
 │  (Java Runtime Environment)   │
 └─────────────▲─────────────────┘
               │
 ┌─────────────┴─────────────┐
 │           JVM             │  ← 바이트코드 실행기
 │  (Java Virtual Machine)   │
 └─────────────▲─────────────┘
               │
 ┌─────────────┴─────────────┐
 │    Java Class Library     │  ← 표준 API (java.lang, util, io 등)
 │ (운영체제와 상호작용 지원)│
 └───────────────────────────┘

```