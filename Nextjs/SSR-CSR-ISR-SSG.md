### 내가 생각하기

- 기본적인 순서 : **소스 코드(JS번들) → 빌드 → (산출물) → CDN → 배포**

  앞이 되어있지 않으면 뒤가 되지 않음 즉, 빌드가 되지 않으면 CDN이 되지 않는다.



#### **SSR**
- 요청이 올 때마다 **서버**에서 HTML을 생성하여 응답하기때문에, JS요청을 하여 그림을 그리기 때문에 꼭 서버가 필요하다.
    - **클라이언트  ↔ 서버** : 요청올 때마다 서버에서 즉석으로 HTML을 그려줌. 
#### **CSR**
- 서버에서 빈페이지 HTML JS번들을 가지고 있고 브라우저에서 요청을 보내면 서버에게 받은JS번들과 HTML 을 브라우저에서 조합한다.
    - **클라이언트 ↔ 서버 :** 빈 HTML + JS 수신 후, 클라이언트에서 API 요청 및 DOM 생성 
#### SSG
- 빌드시 생성된 정적 HTML을 CDN에서 갖고 있다.
    - **클라이언트 ↔ CDN :** 캐시된 CDN 받음
#### ISR
- 정적 페이지로 갖고 있지만, 서버에서 revalidate 조건이 충족되면 새로운 데이터를 받아서 다시 HTML을 그려준다.
    - **클라이언트 ↔ CDN :** 캐시된 CDN 받음

---
### **📂 프론트 서버란?**
- **React / Next.js 코드가 실행되거나, 그 결과물(HTML)을 서빙하는 주체**
- 프론트 서버에는 두 형태가 있다.

**A. 실행 중인 프론트 서버**

- Node.js / Edge Runtime
- Next.js 서버 (`next start`, Vercel, Lambda 등)
    - **코드를 실행해서 HTML을 만들어냄 : 즉석 빌드**

**B. 결과물만 있는 프론트 서버(CDN)**

- S3 + CloudFront
- Nginx 정적 서버
- **이미 만들어진 HTML 파일을 전달만 함**

### 📂 네트워크란?
- TCP/IP, TLS, 라우팅, 인터넷 구간
- CDN 엣지 서버
- 오리진 서버
- Network / Server-side 영역
```
Browser Network Stack
          ↓  ← 이 경계부터
       Internet
          ↓
        CDN
          ↓
     Origin Server

```

### 관련 단어 모음

#### 🔸 빌드 : 파일을 미리 만들다.

- 언제: 개발자가 명령을 실행할 때 (`next build`)
 - 무엇을:
     - TypeScript → JavaScript
     - JSX → JS
     - (SSG일 경우) **HTML 파일 생성**
 - 결과물: 파일
     - `.html`
     - `.js`
     - `.css`

  > **“실행할 준비물을 만드는 과정”**

#### 🔸 서버 : 요청이 올때 연산을 시작하여 적절한 응답(반환이 있긴 있음)한다.
- **언제**: 사용자가 **요청**할 때마다
 - **무엇을**:
     - 코드 실행
     - 데이터 조회
     - 조건 분기
     - (SSR/ISR) HTML 생성
 - **결과물**: 응답(Response)

  > “**요청이 들어오면 판단하고 계산하는 주체**”


  - 서버는 요청을 받으면 **정적 리소스 데이터**를 반환해준다.(JS번들도 정적 리소스이다.)

#### 🔸 **클라이언트** : 요청을 보내는 주체
- 클라이언트 = 브라우저
  - 웹의 아키텍처

      ```
      [클라이언트]  ↔  [프론트 서버]  ↔  [백엔드 서버]
      ```

#### 🔸 엔진 : JS를 실행시키는 주체는 브라우저에 내장되어있는 엔진이다.

#### 🔹 네트워크와 서버의 차이

- **서버 :** 요청이 들어오면 계산하고 응답을 돌려줌  
  - 처리함 (처리하는 뇌)
  

- **네트워크 :** 요청과 응답 사이에서 더 빠르게 수행할수있음.  
  - 처리한 정적 리소스를 처리하는 통로 (통로)


#### 🔹 동적과 정적 차이

- **동적 :** 요청 시점에 내용이 바뀔수있음 .

  - DB데이터에 따라 실시간으로 데이터가 달라짐.


- **정적 :** 빌드 - 한번 생성되면 변하지 않는다. (스냅샷)
---

## 동작 방식 - 렌더링 타이밍

### CSR (Client-side-Rendering)

```
서버 → 빈 HTML + JS 번들
브라우저 → JS 실행
브라우저 → 데이터 요청
브라우저 → DOM 생성 (HTML을 그림)
```
- HTML 생성과 화면 렌더링을 브라우저에서 수행하는 방식
- HTML 생성 주체: 브라우저



### SSR (Server-Side-Rendering)

```
요청 발생
 → 서버에서 데이터 조회
 → HTML 생성
 → 클라이언트 응답
 → Hydration
```
- HTML 생성 주체 : 서버 (네트워크 너머의 서버 실행환경)
- 매 요청마다 서버 렌더리 (연산 발생)
    - **Next fetch** : `fetch(..., { cache: 'no-store' })`
  

- 항상 최신 데이터 보장
- **항상 먼저 서버가 실행되어야 모든 것이 시작됨.**

   → 구조 자체가 api요청도 서버에서 js가 실행되기 때문


### SSG (Static-Site-Generation)

```
빌드 시
 → 모든 페이지 HTML 생성
 → CDN에 배포
 → 요청 시 즉시 응답
```
- HTML 생성 시점: 빌드 타임
- HTML 생성 주체 : 서버 (네트워크 너머의 서버 실행환경)
  - **Next fetch** : 기본 `fetch` 캐시 (`force-cache`)
  

- 런타임 서버 연산 없음
- 데이터 변경 시 재빌드 필요
  - 빌드 시점에 HTML을 스냅샷처럼 생성해 CDN에 배포하므로 데이터 변경 시 재빌드가 필요하다.
- **스냅샷 방식**
    - 특정 시점에 데이터를 스냅샷처럼 찍어서 정적페이지로 만들어두는 방식이다.

### ISR (Incremental-Static-Regeneration)

```
빌드 시
 → 초기 HTML 생성
 → CDN 배포

요청 중
 → revalidate 시간 초과 시
 → 서버에서 백그라운드 재생성
 → 이후 요청부터 새 HTML 제공

```

- 첫 응답은 정적 페이지
    - **Next fetch** : `fetch(..., { next: { revalidate: 60 } })`
  

- 갱신은 서버가 점진적으로 수행
- 정적 HTML을 CDN에 캐시해 두되, 갱신 시점(revalidate)에는 서버가 다시 HTML을 생성하는 방식

## SSG ISR SSR CSR 비교표

| 구분  | HTML 생성 위치 | 생성 시점 | 서버 필요 | 분류    |
| --- | ---------- | ----- | ----- | ----- |
| CSR | 브라우저       | 런타임   | X     | 클라이언트 |
| SSR | 서버         | 요청 시  | O     | 서버    |
| SSG | 서버         | 빌드 시  | O     | 서버    |
| ISR | 서버         | 재검증 시 | O     | 서버    |

- **HTML을 서버에서 만들면 모두 서버 사이드**

---

## 헷갈려요
### ❓ CSR의 실행 흐름


```
[사용자 브라우저]
        ↓
CDN → index.html (정적)
        ↓
CDN → app.js (정적)
        ↓
브라우저에서 JS 실행
        ↓
API 서버 요청 (동적)
        ↓
DB 조회
        ↓
JS가 DOM을 수정
```


