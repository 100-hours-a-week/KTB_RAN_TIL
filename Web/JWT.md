
# JWT (JSON Web Token)


**JWT (Json Web Token)**  
사용자의 인증정보나 데이터를 **안전하게 교환하기 위한 JSON 형식의 문자열**
</aside>



## 키워드

* **토큰화 (Tokenization)**
* **자체 포함형(Self-contained)** 토큰
  → 필요한 인증 정보가 토큰 내부에 모두 포함되어 있다.

즉, **JWT 자체에 사용자의 인증 정보**가 들어 있기 때문에
서버는 로그인 상태를 별도로 저장하지 않아도 된다.
→ **무상태(Stateless) 인증**이 가능하다.

---

## 특징

* JWT는 사용자의 인증 상태를 유지하기 위한 방식으로,
  **서버 부하를 줄이고 Stateless 인증을 가능하게 한다.**
* 토큰은 **클라이언트에 저장**되며, 이후 요청 시 헤더에 포함되어 전송된다.
* 토큰의 핵심 부분은 **페이로드(payload)** 로,
  여기에 사용자의 정보(userId, role, 만료 시간 등)가 담긴다.

---

## JWT 인증의 동작 원리

1. 사용자가 **로그인 요청**을 보낸다.
2. 서버는 사용자 정보를 검증한 뒤,
   `userId`, `role`, `유효기간` 등의 정보를 담은 **JWT를 생성**한다.
3. 서버는 JWT를 클라이언트(브라우저)에게 전달한다.

    * 클라이언트는 이 토큰을 **Local Storage나 Cookie에 저장**한다.
4. 이후 요청 시, 클라이언트는 JWT를 **HTTP Header**에 담아 전송한다.

   ```
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...
   ```
5. 서버는 **Signature(서명)** 을 검증하여
   토큰이 변조되지 않았고 유효기간이 남아 있는지를 확인한다.

    * 유효하면 로그인된 사용자로 인식한다.

---

## JWT 내부 구조

JWT는 `Header.Payload.Signature` 구조로 이루어져 있다.

```
xxxxx.yyyyy.zzzzz
```

### 1. Header

* 토큰의 유형(`typ`)과 서명 알고리즘(`alg`)이 정의된다.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### 2. Payload

* **토큰에 담길 실제 데이터 (클레임, Claims)**
* 사용자 정보, 권한, 발행·만료 시각 등 메타데이터 포함

```json
{
  "userId": 1,
  "name": "상균",
  "role": "USER",
  "iat": 1609239023,
  "exp": 1609242623
}
```

### 3. Signature

* Header + Payload를 합쳐
  지정된 알고리즘으로 해시한 후 **서버 비밀키(secret key)** 로 서명한다.
* 서명(Signature)을 통해 **위조 여부를 검증**할 수 있다.

---

## JWT 예시 구조 요약

```text
Header:   {"alg": "HS256", "typ": "JWT"}
Payload:  {"userId": 1, "name": "상균", "role": "USER", "exp": 1730000000}
Signature: HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

![JWT 구조 다이어그램](attachment\:e1224c7a-4484-4d0d-b139-ef65f5177872\:image.png)

---

## Stateless vs Stateful

JWT는 **Stateless 인증 방식**이다.

> 즉, 서버는 로그인 상태를 별도로 저장하지 않는다.
> 인증의 유효성은 오직 “토큰 자체의 서명 검증”으로 판단한다.

반면 **세션(Session)** 은 **Stateful 인증 방식**이다.

> 서버가 로그인 상태(Session)를 직접 관리하고,
> 클라이언트는 단순히 세션 ID만 쿠키로 보관한다.

---

##  세션 기반 인증 vs JWT 기반 인증

> ### 세션 기반 인증 (Stateful)

* **서버가 상태를 직접 저장** (세션 ID와 사용자 매핑)
* **쿠키**에 세션 ID만 저장
* 서버가 클라이언트의 로그인 상태를 **항상 기억함**

**장점**

* 세션ID는 사용자 정보가 직접 담겨있지 않아 보안성이 높다.
* 세션 무효화(로그아웃, 만료) 제어가 쉬움.

**단점**

* 로드밸런싱 시 서버 간 세션 동기화 필요
* 확장성 문제 발생 (세션 클러스터링 필요)

---

> ### JWT 기반 인증 (Stateless)

* 서버는 로그인 상태를 저장하지 않음
* **JWT 자체에 사용자 정보가 포함되어 있음**
* 클라이언트가 토큰을 직접 보관하고, 매 요청 시 전송

**장점**

* 서버 간 세션 공유가 필요 없어 **확장성 우수**
* 마이크로서비스(MSA) 환경에서 **서비스 간 인증 토큰 재사용** 가능

**단점**

* 토큰 탈취 시 보안 위험 (서버가 강제로 만료시키기 어려움)
* 만료 전까지 유효하므로 **즉시 무효화 불가능**
* Payload가 암호화가 아닌 “인코딩” 상태이므로,
  민감 정보는 포함하지 않아야 함.

---

## 세션 + JWT 혼합 방식

현대 서비스에서는 두 방식을 혼합하여 사용하기도 한다.

* **JWT**는 “인증” (Access Token)
* **세션 or Redis**는 “인가 및 Refresh Token 관리”

>
> * Access Token (JWT): 짧은 만료 시간, 클라이언트 보관
> * Refresh Token (세션 기반): 서버에서 관리하며 만료 시 Access 재발급

이런 구조를 통해

* JWT의 확장성과
* 세션의 보안성을
  둘 다 확보할 수 있다.

