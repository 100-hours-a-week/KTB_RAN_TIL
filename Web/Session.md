
# Session (세션)

  
**특정 활동의 시간 또는 기간**,  
웹에서는 **사용자가 서버에 접속해 있는 동안 유지되는 상태 정보의 저장 단위**
</aside>



### 키워드

* 상태 유지 (Stateful HTTP)
* 서버 측 저장
* 세션 ID
* 로그인, 인증 유지
* 인메모리 저장소 (Redis)

---

## 특징

### 기본 개념

HTTP는 **Stateless**(비상태 프로토콜)이기 때문에,
서버는 기본적으로 “이 요청이 어느 사용자로부터 온 것인지”를 알 수 없다.

이를 해결하기 위한 방법이 바로 **세션(Session)** 이다.
세션은 사용자가 서버에 접속해 있는 동안, **서버 측에 사용자의 상태 정보를 저장**하여
이전 요청의 정보를 기억할 수 있도록 한다.

> 즉, 세션은 **“서버의 기억력”** 이라고 할 수 있다.
> 클라이언트는 단지 세션을 식별하기 위한 **세션 ID**만 가지고 있을 뿐이다.

---

### 세션과 쿠키의 관계

쿠키와 세션은 항상 함께 언급된다.
쿠키가 클라이언트에 저장되는 작은 데이터라면,
세션은 **서버에서 관리되는 사용자 정보 저장소**다.

* 클라이언트(브라우저)는 **세션 ID만 쿠키로 저장**
* 서버는 이 세션 ID를 이용해 **실제 사용자 데이터를 서버 메모리에서 조회**

이렇게 하면, **민감한 정보는 클라이언트에 남지 않고**,
쿠키의 단점을 보완할 수 있다.

---

### 세션 저장 구조

세션의 핵심은 **속도**다.
사용자의 모든 요청마다 세션을 확인해야 하므로, 빠른 접근이 중요하다.

* 세션 데이터는 일반적으로 **메모리 기반 저장소**에 저장된다.
* 대표적인 예: **Redis (인메모리 데이터베이스)**

> Redis는 디스크보다 훨씬 빠른 접근 속도를 제공하지만,
> 메모리 기반이기 때문에 **비용**과 **확장성** 측면에서 신중한 설계가 필요하다.

**메모리와 디스크의 차이**

* 메모리(휘발성, Volatile): 전원이 꺼지면 데이터가 사라짐
* 디스크(비휘발성, Persistent): 영구 저장 가능

따라서 세션은 빠르지만, 휘발성이 높은 메모리 영역에서 관리된다.

---

## 세션을 사용하는 이유

세션은 단순히 로그인 정보를 저장하는 것을 넘어,
**보안 강화와 사용자 맞춤형 경험 제공**을 위해 사용된다.

### 1. 민감한 정보의 안전한 저장 (보안성)

* 쿠키는 클라이언트에 저장되기 때문에 쉽게 열람되거나 조작될 수 있다.
  (보안 수준이 낮음)
* 반면, 세션은 **서버 내부에 저장되므로 외부 노출이 어렵다.**
  (보안 수준이 높음)

### 2. 네트워크 효율성

* 쿠키는 모든 요청마다 자동으로 전송되어 **네트워크 부하를 증가**시킨다.
* 세션은 클라이언트가 세션 ID만 전달하므로, **데이터 전송량이 적다.**

---

## 세션의 종류

세션은 연결의 “지속 범위”에 따라 다양하게 구분된다.

* **로그인 세션:**
  사용자가 로그인한 이후 로그아웃할 때까지 유지
* **HTTP 세션:**
  HTTP 연결이 유지되는 동안만 지속
* **브라우저 세션:**
  브라우저 창 또는 탭이 열려 있는 동안만 유지

---

## 세션의 동작 방식 (로그인 예시)

1. 사용자가 로그인 요청을 보낸다.
2. 서버는 로그인 정보를 검증한 후, 해당 사용자 정보를 **세션 저장소(서버)** 에 저장한다.
3. 서버는 클라이언트에게 응답하면서 **세션 ID** 를 쿠키로 전송한다.

   ```
   Set-Cookie: JSESSIONID=abc123; Path=/; HttpOnly
   ```
4. 브라우저는 세션 ID를 쿠키에 저장한다.
5. 이후 클라이언트가 새로운 요청을 보낼 때, 브라우저는 이 쿠키를 자동으로 첨부한다.

   ```
   Cookie: JSESSIONID=abc123
   ```
6. 서버는 세션 ID를 통해 세션 저장소에서 사용자를 식별하고,
   로그인 상태를 유지할 수 있게 된다.

---

## 세션 클러스터링

대규모 서비스에서는 서버가 여러 대로 나뉘어 동작한다.
이때 한 서버에서 생성된 세션 정보를 다른 서버에서도 접근할 수 있어야 한다.
이런 구조를 **세션 클러스터링(Session Clustering)** 이라고 한다.

### 구현 방식

1. **세션 복제(Session Replication)**

    * 각 서버에 동일한 세션 데이터를 복제하여 유지.
    * 단점: 서버가 많을수록 메모리 낭비 심함.

2. **세션 공유(Session Centralization)**

    * 세션 정보를 Redis 같은 **공용 인메모리 서버**에 저장.
    * 모든 서버가 이 저장소를 참조하므로 일관성 유지가 쉬움.

---

## 쿠키와 세션의 로그인 구조 비교

1. **로그인 시**
서버는 로그인 정보를 검증 후, 세션 생성 → 세션 ID 발급

2. **응답 시**
서버는 `Set-Cookie` 헤더로 세션 ID를 브라우저에 전달
3. **요청 시**
브라우저는 자동으로 쿠키에 담긴 세션 ID를 포함시켜 전송
4. **검증 시**
서버는 세션 저장소에서 세션 ID를 조회해 사용자 정보를 불러옴

> 즉, 세션 로그인은 쿠키를 활용하지만,
> 민감한 정보는 전부 서버에서 관리되므로 보안성이 높다.

---
