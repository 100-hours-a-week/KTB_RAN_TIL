## 💻오늘 알게 된 개념들!

### Optional

- optional
    - NPE 대처를 위해 사용
    - 값이 있을 수도 있고, 없을 수도 있는 객체를 감싸는 래퍼 클래스
- 값이 없을 경우 예외를 던져라 “ 에 사용하는 메서드

    ```tsx
    .orElseThrow(() -> );
    ```


### 예외 처리

1. 요소를 못찾을 때 사용

    ```tsx
    new NoSuchElementException("Book with id " + id + " not found")
    ```

2. optional과 orElseThrow는 같이 쓰지 않는다.

   **orElseThrow()은** Optional을 풀어서 실제 값을 꺼내는 메서드이기 때문.

    ```tsx
       //X 안됨
       public Optional<Map.Entry<Long, BookDto>> findById(long id){
            return Optional.ofNullable(books.entrySet().stream().filter(it -> it.getValue().getId() == id).findFirst().orElseThrow(() -> new IllegalArgumentException("값이 존재하지 않습니다.")));
        }
    ```


> **각종 다양한 예외 클래스**
>
1. `ResponseStatusException` : 예외클래스
- 특징 : 컨트롤러 계층에서 HTTP 상태 코드와 에러 메시지를 전달할 때 사용됨.

```tsx
throw new ResponseStatusException(HttpStatus.상태코드, "메시지");
```

### Stream

stream이 뭘까?

- 순회할 수 있도록 자바 객체의 파이프라인을 만들어주는 것.
- for문으로 돌렸던것을 **stream을 통해 바로 변경가능**
- JS 함수형 화살표 함수는 ⇒ 이렇게 쓰지만, 자바에서는 → 이렇게 사용

### Service 계층 orElseThrow

- service 계층에서는 orElseThrow로 풀어서 예외를 던진다.
- Controller 입장에서는 Optional을 처리할 필요가 없고, 값이 없으면 바로 예외 발생

```tsx
public BookDto getBook(Long id) {
    Book book = bookRepository.findById(id)
        .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "책이 없습니다."));
    return new BookDto(book);
}

```

- Repository 계층

  Optional을 반환함.

  왜냐하면, DB에서 결과가 없을 수도 있기 때문에 null 대신 Optional.empty()를 사용함.

    ```tsx
    Optional<Book> findById(Long id);
    
    ```


Controller에서는 메서드가 무조건 String을 반환한다.

즉, template 하위 파일에 있는 경로를 반환한다.

**두가지 특징**

1. 하위 파일 경로 반환
2. **model**을 통해 파일에 데이터 전달

**model은 뭘까요?**

역할 : controller에서 view로 데이터를 전달할 때 사용하는 데이터 바구니

controller가 model.addAttribute(”이름”,값)을 호출할 경우

템플렛에서 “이름”이라는 바구니에서 값을 꺼내서 사용한다.

```tsx
   @GetMapping()
    public String getList(Model model) {
        List<BookDto> books = bookService.getAllBooks(bookRepository);
        model.addAttribute("books",books);
        return "books/list";
    }
```

## 🎁오늘 알게 된 자바 문법

객체에 대해 정렬 기준을 정하는 법

```tsx
// BookDto 안에 getId() 메서드가 있다고 가정
List<BookDto> list = books.values().stream()
        **.sorted(Comparator.comparing(BookDto::getId)) // id 기준 오름차순**
        .toList(); // Java 16 이상
```

## 🎉실수파티

1. **접근 제어자 - 반환 자료형은 꼭 적어주기!**

```tsx
    //메서드
    public getAllBooks(BookRepository bookRepository){
        return bookRepository.findAll();
    }
```

```tsx
    //메서드
    public List<BookDto> getAllBooks(BookRepository bookRepository){
        return bookRepository.findAll();
    }
```

- return이 반환하는 findAll()은 ArrayList이다.
- List는 인터페이스이기 때문에 구현체가 없다. 때문에 List의 구현체로 반환해주어야한다.
- List의 구현체
    - LinkedList
    - ArrayList

1. **Optional의 중복 래퍼 클래스 사용**

optional은 중복으로 사용하지 못한다.

- optional<BookDto> 자료형 , Optional.ofNullable로 묶는 것은 중복이다.
- Optional에서 return할때는 감싸지 않는다.

```tsx
    //❌
public Optional<BookDto> findById(long id){
    return Optional.ofNullable(
        books.values().stream()
             .filter(it -> it.getId() == id)
             .findFirst()   // ⚠️ 이미 Optional<BookDto> 반환
    );
}
```

```tsx
    //id == sequence로 찾기같은데
    //✅옳은 코드
    public Optional<BookDto> findById(long id){
        return books.values().stream().filter(it -> it.getId() == id).findFirst();
    }
```

## 😤생각해보기

### 각 파일의 용도

1. **dto**
    - 간단한 데이터 형식
    - **개별 단위의 객체 속성을 저장**
2. **repository**
    - DB에 직접 접근
    - **큰 단위의 객체 속성을 저장**
3. **service**
    - 비즈니스 로직
    - controller에서 필요로 하는 **메서드를 작성**
4. **controller**
    - view 및 클라이언트 **htmlcss와 가장 상위에 있는 계층**

---

## 회고

DTO Controller Service 각각 하는 일을 명확하게 알아야겠음.

이론만 줄 글로 읽을 땐 지루했는데, 코드로 요구사항별로 직접 설계하고 작성하니까 이론이 훨씬 더 궁금해지는 것 같다.

특히 IoC와 DI가 어떻게 spring에 설계되어 순수 자바 개발보다 편리성의 차이점을 더 자세하게 알고싶어졋다

프론트엔드만 개발하던 내가 Spring을 제대로 개발해보려 하다니 감회가 새롭다🥹

### 어렵다. 하지만 시간과 노력이 해결해주겟지?