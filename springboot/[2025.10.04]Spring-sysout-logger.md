<aside>
🍀

당연한 일을 꾸준히, 날마다 쌓아 올리는 사람이 진짜가 된다.

— Ace Of Diamond —

</aside>

제가 정말 좋아하는 만화에 나온 명대사 중 하나입니다.

기록이 대수야? 라고 생각했던 저에게 큰 깨달음을 건네준 최고의 대사입니다.

---

## 백엔드 왕초보의 spring과 친해지기 #2

spring으로 작업을 진행 하다보니 메서드 별로 굉장히 잘 나누어지는 것을 확인할 수 있는데, 이 메서드가 정상적인 코드인지 의구심이 들었습니다.

그래서, 로그를 확인하기 위해서 sysout을 의심치 않고 사용했는데 spring을 작성할 때는 sysout을 권장하지 않는다는 동료의 일침이 있었습니다…! (알려주셔서 정말 감사해요…….🥹)

해당 글은 **1 왜 권장되지 않는지, 2 spring에서 로그를 확인하는 추천하는 방식이 무엇인지** 정리한 TIL입니다.

**🎁 잘못된 정보 및 배움이 있다면 정정을 언제든 환영합니다!**

---

## sysout이 권장되지 않는 이유

- **(sysout) System.out.println() :** 개발할 때 디버깅 용도로 콘솔에 출력할 때 사용한다.

1. **sysout의 병목 현상 야기**

sysout은 직접 입출력(I/O)을 발생시키기 때문에 속도가 매우 느리다.

아래 코드를 통해 println은 **synchronized block으로 동작**되는 것을 확인할 수 있다.

```tsx
System.out.println("hello world");
```

아래 그림 println의 내부 동작 설명 그림

![image.png](attachment:77c034de-965e-4038-8b69-222b78517190:image.png)

→ 그림 설명

동시에 여러 스레드가 해당 println에 접근하지 못하도록 lock을 걸어 단일로 출력하도록 한다.

때문에 println으로 콘솔을 출력하는 동안 **스레드가 대기 상태로 변하기 때문에** 전체 성능을 감소시키는 병목 현상을 야기할 수 있다.

1. **로그 레벨 관리가 되지 않음**

로그의 중요도(레벨)을 구분해서 관리할 수 없습니다.

→ log level의 분리

```tsx
log.debug("디버깅용 메시지");
log.info("정상 동작 메시지");
log.warn("경고 메시지");
log.error("에러 발생!");
```

반면, sysout은 println만 출력합니다.

```tsx
System.out.println("error");
```

**→ ⭐⭐sysout이 아니라 실무에서는 로거(logger)를 사용한다!**

해당 레퍼런스에서 logger + sysout 의 조합으로 성능을 개선한 자세한 수치를 확인할 수 있습니다.

[System.out.println 메소드는 실무에서 `절대 사용하지마라.`](https://systemdata.tistory.com/21)

---

## 로거(logger)란

- 로거(logger)는 프로그램 실행 중에 발생하는 정보를 기록(log)하는 도구
1. (Async)별도 로깅 스레드에서 관리하기 때문에 I/O 대기에 영향을 받지 않는다.
2. buffer를 사용하여 로그 메시지를 모아서 기록

> **sysout vs logger 비교표**
>

| 구분 | **System.out.println()** | **Logger (log.info 등)** |
| --- | --- | --- |
| 목적 | 단순 콘솔 출력 | 시스템 로그 관리 |
| 속도 | 느림 (I/O 직접 발생) | 빠름 (비동기 처리 가능) |
| 출력 위치 | 콘솔만 | 콘솔 + 파일 + 클라우드 등 다양 |
| 로그 레벨 | ❌ 없음 | ✅ 있음 (`INFO`, `WARN`, `ERROR`, `DEBUG`) |
| 운영 환경 | 개발용 | 운영용 (로그 필터링, 수집 가능) |

> **로깅 라이브러리 사용하기 : SLF4J와 Logback**
>

기본적으로 spring boot 라이브러리 안에 spring boot 로깅 라이브러리가 내장되어있다.

→ 별도의 의존성 추가 없이 바로 `org.slf4j.Logger` 를 사용할 수 있다.

SLF4J는 인터페이스이고, 구현체로 Logback, log4j 등이 있지만 logback을 많이 사용한다고 한다.

[System.out.println 메소드는 실무에서 `절대 사용하지마라.`](https://systemdata.tistory.com/21)

---

## React vs Spring boot의 로그 확인법 차이

관점의 차이를 만들게 한 프론트엔드에서 자주 사용되는 React와 백엔드의 Spring의 로그 차이

### 🔸React (Frontend)의 로그

- **동작 환경 :** 브라우저 / **로그 도구** : console
- **로그 확인 위치** : 브라우저 개발자 도구 - console 탭

```tsx
useEffect(() => {
  console.log("API 응답:", response);
  console.warn("경고: 데이터가 없습니다.");
}, [response]);
```

### 🔹Spring Boot (Backend)의 로그

- **동작 환경 :** Java 서버 / **로그 도구** : logger (Logback / SLFAJ)

```tsx
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class BookController {

    private static final Logger log = LoggerFactory.getLogger(BookController.class);

    public void getBook() {
        log.info("도서 조회 요청 발생");
        log.warn("데이터가 존재하지 않습니다.");
    }
}

```

---

## 로거 사용하기

### 문제의 “그” 코드

```tsx
    //목록 반환 메서드
    @GetMapping()
    public String getList(Model model) {
        List<BookDto> books = bookService.getAllBooks();
        model.addAttribute("books",books);
        **System.out.println(model); <<< 이 구간**
        return "books/list";
    }
```

> **기존의 콘솔 로그**
```java
{books=[BookDto [id=1, title=Clean Code, author=Robert C. Martin, description=소프트웨어 장인 정신을 담은 책입니다., isbn=9780132350884], BookDto [id=2, title=객체지향의 사실과 오해, author=조영호, description=객체지향의 본질을 쉽게 설명합니다., isbn=9791186710770], BookDto [id=3, title=Effective Java, author=Joshua Bloch, description=자바 개발자를 위한 베스트 프랙티스 모음집입니다., isbn=9780134685991]]}
```

![image.png](attachment:9d892b49-f981-4e6f-9252-0d948336f7b0:image.png)

### logger를 이용한 로그 조회

1. slf4j를 import
2. Logger 인스턴스 생성
3. Logger 메서드 사용 (`log.info`, `log.error` 등)

```java
//기존 코드에서 추가된 코드만 작성해두었습니다ㅏ
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
...
@Controller
@RequestMapping("/books")
public class BookController {

    private static final Logger logger = LoggerFactory.getLogger(BookController.class);
		
		...
		    //목록 반환 메서드
    @GetMapping()
    public String getList(Model model) {
        List<BookDto> books = bookService.getAllBooks();
        model.addAttribute("books",books);
//        System.out.println(model);
        logger.info("book list model:{}",model);
        return "books/list";
    }
		
```

> **로거의 로그 출력**
>

![image.png](attachment:7146a1ae-8d82-4a25-9bfb-568bd013f497:image.png)

```java
2025-10-05T03:51:52.362+09:00  INFO 23368 --- [springmvcpractice] [nio-8080-exec-1] c.r.s.controller.BookController : book list model:{books=[BookDto ...]}
```

- **로그 해석하기**
1. **2025-10-05T03:51:52.362+09:00  :** 로그 발생 시각
2. **INFO**  로그레벨
3. **23368**  프로세스 ID (JVM 실행 식별자)
4. **[springmvcpractice]** 애플리케이션 이름
5. **[nio-8080-exec-1]** 요청한 스레드 이름
6. **c.r.s.controller.BookController :** 로그를 요청한 클래스
7. **book list model:{books=[...]} :** 로그 본문

> System.out.println 과 비교하기
>

**노란색 표시** : sysout 사용

**파란색 표시** : logger 사용

- 로그 레벨과 상세한 로그 관리가 가능하도록 **출력된 logger**가 개발의 다방면에서 더욱 빛이 날 것으로 보인다. → **logger 안쓸이유가 전혀 없다!**

<img width="1629" height="371" alt="Image" src="https://github.com/user-attachments/assets/8c3daed9-f426-4e25-b403-86057d34db0b" />

### **💡 오늘의 인사이트**

System.out.println()은 전체 성능을 저하시킬 수 있는 잠재적 병목 현상을 가진다.

따라서 Spring에서는 **비동기식으로 동작하여 I/O 부하를 최소화하는 Logger를 사용해 로그를 출력하는 것이 강력히 권장된다.**

### 회고

우선, 동료가 sysout과 lombok에 대해 말씀해주시지 않았더라면 아마 평생 sysout만을 고집하며 로그를 확인했을 것입니다… 좋은 글 공유해주신 동료분께 감사인사를 올립니다-!!! 🙇‍♀️

로그를 확인하려면 테스트코드를 작성해야하나 sysout으로 출력해야하나 고민했었는데 실무에서 logger를 많이 사용한다는 것을 알게되어 이번 기회에 logger를 사용하여 로그를 남기는 좋은 경험이 될 것이라고 생각합니다!

확실히 logger를 몇번 안써봤음에도 단순하게 “출력”만을 동작하는 sysout과 비교되어 logger를 안쓸 이유가 전혀 없다고 생각합니다… logger 물건이네요! 애용해야겠습니다
