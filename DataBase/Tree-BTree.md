
# Tree, B-Tree, B+Tree


## 키워드

* 트리(Tree) 구조
* 순환 없는 연결 그래프
* **B-Tree / B+Tree** : DB 인덱스의 핵심 자료구조
* 디스크 I/O 최소화

---

## 특징

### Tree란?

* **순환이 없는 연결 그래프**
* 부모-자식 관계로 구성된 **계층적 구조**
* 루트(Root)부터 시작해서 하위 노드(Child)로 이어짐

---

### BST (Binary Search Tree)

* **이진 탐색 트리 (Binary Search Tree)**
  → 왼쪽은 작은 값, 오른쪽은 큰 값

```text
      (10)
      /  \
    (5)  (15)
```

* 탐색 효율이 높지만, **값이 한쪽으로 편향되면(O(N)) 속도가 급격히 저하됨.**
  → “오른쪽으로 쏠린 트리(Right Skewed Tree)” 발생 가능

---

### B-Tree

> **효율적인 데이터 검색을 위해 설계된 디스크 기반 트리 구조**

* DB는 디스크에 데이터를 저장한다.
  하지만 디스크 접근은 메모리보다 **수천 배 느리다.**
* 따라서 DB는 데이터를 **한 번에 ‘페이지(Page)’ 단위로 읽어들인다.**
* B-Tree는 이 특성에 맞게 설계되어, **디스크 I/O를 최소화**한다.

#### 특징

* 트리의 높이를 낮추기 위해 **하나의 노드에 여러 데이터(Key)를 저장**
* 노드가 꽉 차면 분할(Split)되어 균형을 유지
* 리프 노드에는 **실제 데이터(행 블록)** 가 저장된다.

```sql
[B-Tree Index]
 └── Leaf Node = 실제 데이터가 정렬된 상태로 저장됨

예시)
id (PK) 기준으로 정렬된 데이터 테이블

+----+--------+--------+
| id | name   | age    |
+----+--------+--------+
|  1 | Alice  | 24     |
|  2 | Bob    | 30     |
|  3 | Carol  | 27     |
+----+--------+--------+
```

#### 장점

* 디스크 접근 횟수를 줄임
* 정렬된 상태 유지로 검색 효율 높음

#### 단점

* **중간 노드에도 데이터가 들어감**
  → 데이터 중복 / 범위 검색 시 비효율 발생

---

### B+Tree

> MySQL **InnoDB 엔진**에서 실제 사용하는 인덱스 구조
> (InnoDB = MySQL의 데이터 저장 방식을 결정하는 스토리지 엔진)

**InnoDB란?**  
MySQL에서 데이터를 “어떻게 저장할지”를 결정하는 **저장 엔진(Storage Engine)**  
→ 트랜잭션, 외래키, 인덱스, 버퍼풀 등을 직접 관리한다.


---

#### B+Tree의 구조적 특징

1. **모든 데이터는 리프 노드(Leaf Node)에만 저장됨**

    * 중간 노드는 **자식 노드를 찾기 위한 Key만 저장**
    * 즉, **실제 데이터는 리프 노드에만 존재**
    * ➜ 중간 노드에 더 많은 Key를 담을 수 있으므로 **트리의 높이를 낮출 수 있음**
    * ➜ 디스크 I/O 최소화

2. **리프 노드 간 연결 (Linked List 구조)**

    * 리프 노드들이 **포인터로 연결되어 있음**
    * ➜ **범위 검색(Range Scan)** 에 압도적으로 유리
      (예: `WHERE age BETWEEN 20 AND 30`)

3. **페이지(Page) 단위 저장**

    * DB의 기본 저장 단위 = Page
    * 각 페이지는 B+Tree의 **노드** 역할을 함

        * **루트 페이지(Root Page):** 검색의 시작점
        * **중간 페이지(Internal Node):** 탐색 경로를 빠르게 만들어줌
        * **리프 페이지(Leaf Page):** 실제 데이터(혹은 포인터)가 저장된 노드

```text
[탐색 흐름 예시]
루트 → 중간 페이지 → 리프 페이지
```

---

### 범위 검색 예시

B+Tree는 리프 노드가 연결되어 있기 때문에
**“20세 이상 30세 이하”** 같은 범위 조건이 매우 효율적이다.

```text
[리프 노드 간 연결]
[20] → [25] → [27] → [30] → [33]
```

→ 연결된 포인터를 따라 순차적으로 탐색 가능
→ 디스크 I/O 최소화 + 빠른 연속 조회

---

### 페이지 구조 요약

| 페이지 구분                 | 설명                            |
| ---------------------- | ----------------------------- |
| 루트 페이지 (Root Page)     | 인덱스의 최상위 노드, 검색 시작 지점         |
| 중간 페이지 (Internal Page) | 검색 경로를 가속화하는 중간 단계            |
| 리프 페이지 (Leaf Page)     | 실제 데이터의 주소(포인터) 혹은 데이터 자체를 저장 |



#### 직접 시각화 해보기

 [B+Tree 시각화 도구 (University of San Francisco)](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

---

#### B+Tree의 장점 정리

* 트리의 높이가 낮아 디스크 접근 횟수 최소화
* 리프 노드 간 연결로 **범위 검색 최적화**
* 중간 노드에 데이터가 없어 더 많은 Key를 저장 가능
* **InnoDB 인덱스의 기본 구조**

---

####  단점

* 인덱스 탐색 후 **데이터 접근까지 2번의 I/O** 필요
  (한 번은 인덱스 검색, 한 번은 실제 데이터 조회)

---

## 요약

| 구분           | B-Tree         | B+Tree                    |
| ------------ | -------------- | ------------------------- |
| 데이터 저장 위치    | 모든 노드(중간 + 리프) | 리프 노드에만 저장                |
| 리프 노드 연결     | ❌ 없음           | ✅ 포인터로 연결 (Range Scan 유리) |
| 트리 높이        | 상대적으로 높음       | 낮음 (검색 효율 ↑)              |
| 디스크 I/O      | 더 많음           | 더 적음                      |
| InnoDB 사용 여부 | ❌              | ✅ 사용                      |

---

### 참고 자료

* [엔지니어 대한민국 - 인덱스가 뭔지 설명해보세요 (YouTube)](https://youtu.be/iNvYsGKelYs?si=xOKGhKZ79fCDcByz)
* [B+Tree 시각화 사이트 (USF)](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

---
