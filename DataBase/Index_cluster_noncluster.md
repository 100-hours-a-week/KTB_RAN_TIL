
# 인덱스 (Index)

 
데이터베이스에서 **테이블 조회 속도를 높이기 위한 자료구조.**  
→ 데이터를 빠르게 찾기 위해, 특정 컬럼을 기준으로 **검색 경로를 미리 만들어 둔 구조**다.


---

### 키워드

* 조회 성능 향상
* 디스크 I/O 최소화
* B+Tree 기반 자료구조
* Trade-off (읽기 속도 ↔ 쓰기 성능)


## 특징

인덱스는 **테이블의 특정 컬럼**을 기준으로 검색을 빠르게 해주는 구조이다.
테이블 전체를 탐색(Full Table Scan)하는 것보다 훨씬 빠르다.

> 인덱스는 쿼리문에서 선택적으로 생성할 수 있으며,
> **“자주 검색되는 컬럼”** 위주로만 만들어야 한다.
> (인덱스는 항상 2단계 탐색을 거치기 때문에 남용은 오히려 성능 저하)



> #### 디스크 I/O란?


디스크에서 데이터를 **읽고(Read)** 쓰는(Write) 행위를 의미한다.  
디스크는 CPU·메모리에 비해 매우 느리기 때문에,  
**DB 성능 튜닝의 핵심은 디스크 접근을 최소화하는 것**이다.




### 인덱스의 단점

* **물리적 저장 공간 차지**
  → 인덱스도 결국 별도의 자료구조이므로, 디스크 용량이 증가한다.
* **CUD(Create, Update, Delete) 성능 저하**
  → 데이터가 바뀔 때마다 인덱스도 갱신해야 하기 때문.

> 결국, **읽기 속도 향상을 위해 쓰기 속도와 저장공간을 희생하는 구조.**
> 모든 것은 Trade-off다.

---

## 클러스터형 인덱스 (Clustered Index)

> 데이터 자체를 인덱스 키 순서대로 **물리적으로 정렬하여 저장하는 구조.**

* **기본 키(PK)** 가 클러스터형 인덱스로 자동 설정된다.
  (테이블 구조 자체가 클러스터형 인덱스임)

```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(255)
);
```

→ `id`는 클러스터형 인덱스 키
→ 실제 데이터 파일 자체가 `id` 순으로 정렬된 **B+Tree 구조**로 저장됨.

**장점**

* 정렬된 상태로 저장되어 **PK 검색 속도 빠름**

**단점**

* CUD 성능 저하 (정렬 순서를 맞추기 위해 데이터 재배치 필요)

**예시**

| id | name  | age |
| -- | ----- | --- |
| 1  | Alice | 24  |
| 2  | Bob   | 30  |
| 3  | Carol | 27  |

→ Leaf Node에 **실제 데이터**가 정렬된 상태로 저장됨.

---

## 비클러스터형 인덱스 (Non-Clustered / Secondary Index)

> 데이터와 별도의 공간에 **인덱스 페이지(index page)** 를 생성하여
> “키 값 + 데이터 위치(포인터)”를 저장하는 구조.

```sql
CREATE INDEX idx_users_email ON users(email);
```

→ `users` 테이블의 email 컬럼 기준으로 **독립적인 B+Tree**가 생성된다.

* 실제 데이터는 그대로 두고, 인덱스 페이지만 별도로 존재.
* 리프 노드에는 **데이터 위치를 가리키는 포인터(PK)** 가 저장됨.
* 하나의 테이블에 **여러 개의 비클러스터 인덱스**를 가질 수 있다.

**장점**

* 클러스터형보다 CUD 속도 빠름 (데이터 재정렬 불필요)

**단점**

* 조회 시 2단계 접근 필요
  → 인덱스 탐색 → 포인터로 데이터 조회

---

### 💡 인덱스 페이지란?

인덱스 데이터가 저장된 **논리적 페이지 단위.**
특정 키 값과 원본 데이터 위치(포인터)가 함께 저장된다.

```text
Index Page → [Key : "연시완"] → Pointer(Page 7, Offset 40)
```


### 💡 페이지(Page)란?

> 데이터베이스의 **저장 단위**.
> 하나의 테이블은 여러 페이지 단위로 나뉘어 저장된다.

---

### 구조 예시

```text
[B-Tree Index]
 └── Leaf Node = 데이터 위치(Row ID, Pointer)

예)
name 컬럼에 비클러스터 인덱스 생성 시

Index
+--------+-----------+
| name   | RID (행주소) |
+--------+-----------+
| Alice  | 0x001     |
| Bob    | 0x002     |
| Carol  | 0x003     |
+--------+-----------+

실제 데이터 (Heap)
+----+--------+--------+
| id | name   | age    |
+----+--------+--------+
|  1 | Alice  | 24     |
|  2 | Bob    | 30     |
|  3 | Carol  | 27     |
+----+--------+--------+
```

---

## 복합 인덱스 (Composite Index)

> 여러 컬럼을 **하나의 인덱스**로 묶은 구조.

```sql
CREATE INDEX idx_user_name_age ON users(name, age);
```

**특징**

* 컬럼 순서가 인덱스 성능에 직접적인 영향을 미친다.
* **WHERE 절에서 자주 사용되고, 카디널리티(값의 다양성)가 높은 컬럼을 앞에 두어야 한다.**

예: `Location, Name` 복합 인덱스 → Location 기준으로 정렬 후 Name 정렬.

---

## 커버링 인덱스 (Covering Index)

> 쿼리에 필요한 모든 컬럼이 인덱스 안에 포함되어 있어
> **테이블을 직접 조회할 필요가 없는 인덱스.**

```sql
CREATE INDEX idx_user_name_age ON users(name, age);

-- 커버링 인덱스 예시
SELECT name, age FROM users WHERE name = 'Alice';
```

→ 이미 `name`과 `age` 컬럼이 인덱스에 포함되어 있어
테이블 접근이 불필요 → **DB I/O가 줄어들어 성능 향상.**

---

## Key Lookup

> 비클러스터형 인덱스에서 찾은 **PK 값으로 실제 데이터를 재탐색하는 과정.**

```sql
SELECT * FROM users WHERE email = 'abc@example.com';
```

1. `email` 인덱스에서 `'abc@example.com'` 을 찾음 → **PK값 획득**
2. 그 PK를 이용해 **클러스터형 인덱스 데이터로 재조회**

> ❓ “PK가 포인터라면 순회 없이 바로 접근 가능한 거 아닌가요?”
> → B+Tree 구조 상, 포인터는 **리프 노드 단위 주소 정보**이므로
> 최종 데이터 접근 시엔 한 번 더 탐색이 필요하다.
> (이 과정을 Key Lookup이라 부름)

---

## Query Optimizer (쿼리 옵티마이저)

> 데이터베이스가 **쿼리를 어떻게 실행해야 가장 빠를지 자동으로 결정하는 엔진.**

* 인덱스를 사용할지, 전체 스캔을 할지 등을 판단함.
* 실행 계획(Execution Plan)을 통해 내부 동작을 확인할 수 있음.

```sql
EXPLAIN SELECT * FROM users WHERE name = 'Alice';
```

→ 옵티마이저가 선택한 인덱스, 탐색 방식, I/O 비용 등을 분석 가능.

---

## 회고

* 인덱스는 **조회 성능 최적화의 핵심**이지만,
  쓰기 작업이 많은 환경에서는 오히려 **부담이 될 수 있다.**
* 실제 프로젝트에서는 **읽기 패턴 / 쓰기 패턴 / 조회 빈도**를 고려해야 하며,
  무조건 많이 만든다고 좋은 게 아니다.
* 결국 핵심은

  > “**디스크 I/O를 얼마나 줄이느냐**” 로 요약된다.
